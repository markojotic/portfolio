<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mood Slider</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Outfit', sans-serif;
      background: #0a0a0a;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
      user-select: none;
      -webkit-user-select: none;
      touch-action: pan-y;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
      width: 100%;
      max-width: 500px;
    }

    .shape-container {
      width: 200px;
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    @media (min-width: 640px) {
      .shape-container {
        width: 280px;
        height: 280px;
      }
    }

    .shape {
      width: 100%;
      height: 100%;
    }

    .shape.bounce {
      animation: bounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes bounce {
      0% { transform: scale(1); }
      30% { transform: scale(1.15); }
      50% { transform: scale(0.95); }
      70% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .glow {
      position: absolute;
      width: 120%;
      height: 120%;
      border-radius: 50%;
      filter: blur(60px);
      opacity: 0.4;
      transition: background-color 0.4s ease;
      pointer-events: none;
      z-index: -1;
    }

    .label {
      font-size: 32px;
      font-weight: 600;
      color: #ffffff;
      text-align: center;
      min-height: 48px;
    }

    @media (min-width: 640px) {
      .label {
        font-size: 42px;
      }
    }

    .label.pop {
      animation: labelPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes labelPop {
      0% { transform: scale(1); opacity: 0.7; }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); opacity: 1; }
    }

    .slider-container {
      width: 100%;
      padding: 0 10px;
    }

    .slider-track {
      position: relative;
      width: 100%;
      height: 8px;
      background: #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
    }

    .slider-progress {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      border-radius: 4px;
      pointer-events: none;
    }

    .slider-thumb {
      position: absolute;
      top: 50%;
      width: 32px;
      height: 32px;
      background: #ffffff;
      border-radius: 16px;
      transform: translate(-50%, -50%);
      cursor: grab;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      z-index: 10;
    }

    .slider-thumb:hover {
      transform: translate(-50%, -50%) scale(1.1);
    }

    .slider-thumb:active,
    .slider-thumb.dragging {
      cursor: grabbing;
      transform: translate(-50%, -50%) scale(1.15);
      box-shadow: 0 6px 30px rgba(0, 0, 0, 0.5);
    }

    .slider-thumb.snap {
      animation: thumbSnap 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes thumbSnap {
      0% { transform: translate(-50%, -50%) scale(1.15); }
      50% { transform: translate(-50%, -50%) scale(0.9); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .particles {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: visible;
    }

    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      opacity: 0;
      pointer-events: none;
    }

    .particle.burst {
      animation: particleBurst 0.6s ease-out forwards;
    }

    @keyframes particleBurst {
      0% {
        opacity: 0.9;
        transform: translate(calc(var(--tx) * 0.5), calc(var(--ty) * 0.5)) scale(0);
      }
      15% {
        opacity: 1;
        transform: translate(calc(var(--tx) * 0.7), calc(var(--ty) * 0.7)) scale(1);
      }
      100% {
        opacity: 0;
        transform: translate(var(--tx), var(--ty)) scale(0.5);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="shape-container">
      <div class="glow" id="glow"></div>
      <div class="particles" id="particles"></div>
      <svg class="shape" id="shape" viewBox="-20 -20 290 290" preserveAspectRatio="xMidYMid meet">
        <path id="morphPath" fill="#F76808"/>
        <g id="face">
          <!-- Left eye -->
          <ellipse id="leftEye" cx="100" cy="115" rx="8" ry="10" fill="#000"/>
          <!-- Right eye -->
          <ellipse id="rightEye" cx="150" cy="115" rx="8" ry="10" fill="#000"/>
          <!-- Mouth -->
          <path id="mouth" fill="none" stroke="#000" stroke-width="5" stroke-linecap="round"/>
        </g>
      </svg>
    </div>
    
    <div class="label" id="label">No way</div>
    
    <div class="slider-container">
      <div class="slider-track" id="track">
        <div class="slider-progress" id="progress"></div>
        <div class="slider-thumb" id="thumb"></div>
      </div>
    </div>
  </div>

  <script>
    // ============ CUSTOM PATH INTERPOLATION ============
    
    // Parse SVG path to array of {type, points} commands
    function parsePath(d) {
      const commands = [];
      const regex = /([MLCQAZ])([^MLCQAZ]*)/gi;
      let match;
      
      while ((match = regex.exec(d)) !== null) {
        const type = match[1].toUpperCase();
        const args = match[2].trim();
        const numbers = args.length > 0 
          ? args.split(/[\s,]+/).map(Number) 
          : [];
        commands.push({ type, numbers });
      }
      
      return commands;
    }
    
    // Evaluate a cubic bezier at parameter t
    function cubicBezier(p0, p1, p2, p3, t) {
      const mt = 1 - t;
      return {
        x: mt*mt*mt*p0.x + 3*mt*mt*t*p1.x + 3*mt*t*t*p2.x + t*t*t*p3.x,
        y: mt*mt*mt*p0.y + 3*mt*mt*t*p1.y + 3*mt*t*t*p2.y + t*t*t*p3.y
      };
    }
    
    // Sample a path into N evenly spaced points
    function samplePath(d, numPoints) {
      const commands = parsePath(d);
      const points = [];
      let currentX = 0, currentY = 0;
      let startX = 0, startY = 0;
      
      // First, collect all segments as cubic beziers
      const segments = [];
      
      for (const cmd of commands) {
        const n = cmd.numbers;
        
        switch (cmd.type) {
          case 'M':
            currentX = n[0];
            currentY = n[1];
            startX = currentX;
            startY = currentY;
            break;
            
          case 'L':
            // Convert line to cubic bezier
            const lx = n[0], ly = n[1];
            segments.push({
              p0: {x: currentX, y: currentY},
              p1: {x: currentX + (lx - currentX) / 3, y: currentY + (ly - currentY) / 3},
              p2: {x: currentX + 2 * (lx - currentX) / 3, y: currentY + 2 * (ly - currentY) / 3},
              p3: {x: lx, y: ly}
            });
            currentX = lx;
            currentY = ly;
            break;
            
          case 'C':
            // Cubic bezier
            for (let i = 0; i < n.length; i += 6) {
              segments.push({
                p0: {x: currentX, y: currentY},
                p1: {x: n[i], y: n[i+1]},
                p2: {x: n[i+2], y: n[i+3]},
                p3: {x: n[i+4], y: n[i+5]}
              });
              currentX = n[i+4];
              currentY = n[i+5];
            }
            break;
            
          case 'Q':
            // Quadratic to cubic
            for (let i = 0; i < n.length; i += 4) {
              const qx1 = n[i], qy1 = n[i+1];
              const qx2 = n[i+2], qy2 = n[i+3];
              segments.push({
                p0: {x: currentX, y: currentY},
                p1: {x: currentX + 2/3 * (qx1 - currentX), y: currentY + 2/3 * (qy1 - currentY)},
                p2: {x: qx2 + 2/3 * (qx1 - qx2), y: qy2 + 2/3 * (qy1 - qy2)},
                p3: {x: qx2, y: qy2}
              });
              currentX = qx2;
              currentY = qy2;
            }
            break;
            
          case 'Z':
          case 'z':
            if (Math.abs(currentX - startX) > 0.01 || Math.abs(currentY - startY) > 0.01) {
              segments.push({
                p0: {x: currentX, y: currentY},
                p1: {x: currentX + (startX - currentX) / 3, y: currentY + (startY - currentY) / 3},
                p2: {x: currentX + 2 * (startX - currentX) / 3, y: currentY + 2 * (startY - currentY) / 3},
                p3: {x: startX, y: startY}
              });
            }
            currentX = startX;
            currentY = startY;
            break;
        }
      }
      
      if (segments.length === 0) return points;
      
      // Estimate total length by sampling
      const samplesPerSegment = 20;
      let lengths = [];
      let totalLength = 0;
      
      for (const seg of segments) {
        let segLength = 0;
        let prevPt = seg.p0;
        for (let i = 1; i <= samplesPerSegment; i++) {
          const t = i / samplesPerSegment;
          const pt = cubicBezier(seg.p0, seg.p1, seg.p2, seg.p3, t);
          segLength += Math.sqrt((pt.x - prevPt.x) ** 2 + (pt.y - prevPt.y) ** 2);
          prevPt = pt;
        }
        lengths.push(segLength);
        totalLength += segLength;
      }
      
      // Sample evenly along total length
      for (let i = 0; i < numPoints; i++) {
        const targetDist = (i / numPoints) * totalLength;
        
        let accumulated = 0;
        let segIndex = 0;
        
        // Find which segment contains this distance
        while (segIndex < segments.length - 1 && accumulated + lengths[segIndex] < targetDist) {
          accumulated += lengths[segIndex];
          segIndex++;
        }
        
        // Find t within segment
        const seg = segments[segIndex];
        const distInSeg = targetDist - accumulated;
        const tApprox = lengths[segIndex] > 0 ? distInSeg / lengths[segIndex] : 0;
        
        const pt = cubicBezier(seg.p0, seg.p1, seg.p2, seg.p3, Math.min(1, Math.max(0, tApprox)));
        points.push(pt);
      }
      
      return points;
    }
    
    // Interpolate between two point arrays
    function interpolatePoints(points1, points2, t) {
      const result = [];
      const len = Math.min(points1.length, points2.length);
      
      for (let i = 0; i < len; i++) {
        result.push({
          x: points1[i].x + (points2[i].x - points1[i].x) * t,
          y: points1[i].y + (points2[i].y - points1[i].y) * t
        });
      }
      
      return result;
    }
    
    // Convert points back to smooth SVG path
    function pointsToPath(points) {
      if (points.length < 2) return '';
      
      // Use Catmull-Rom to cubic bezier conversion for smooth curves
      let d = `M ${points[0].x.toFixed(2)} ${points[0].y.toFixed(2)}`;
      
      for (let i = 0; i < points.length; i++) {
        const p0 = points[(i - 1 + points.length) % points.length];
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const p3 = points[(i + 2) % points.length];
        
        // Catmull-Rom to Bezier conversion
        const cp1x = p1.x + (p2.x - p0.x) / 6;
        const cp1y = p1.y + (p2.y - p0.y) / 6;
        const cp2x = p2.x - (p3.x - p1.x) / 6;
        const cp2y = p2.y - (p3.y - p1.y) / 6;
        
        d += ` C ${cp1x.toFixed(2)} ${cp1y.toFixed(2)}, ${cp2x.toFixed(2)} ${cp2y.toFixed(2)}, ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
      }
      
      d += ' Z';
      return d;
    }
    
    // Simple mouth path interpolation (for open quadratic curves)
    function interpolateMouth(mouth1, mouth2, t) {
      // Parse simple "M x y Q cx cy x2 y2" format
      const parse = (m) => {
        const nums = m.match(/-?[\d.]+/g).map(Number);
        return { x1: nums[0], y1: nums[1], cx: nums[2], cy: nums[3], x2: nums[4], y2: nums[5] };
      };
      
      const m1 = parse(mouth1);
      const m2 = parse(mouth2);
      
      const lerp = (a, b) => a + (b - a) * t;
      
      return `M ${lerp(m1.x1, m2.x1).toFixed(2)} ${lerp(m1.y1, m2.y1).toFixed(2)} Q ${lerp(m1.cx, m2.cx).toFixed(2)} ${lerp(m1.cy, m2.cy).toFixed(2)} ${lerp(m1.x2, m2.x2).toFixed(2)} ${lerp(m1.y2, m2.y2).toFixed(2)}`;
    }
    
    // ============ MOOD CONFIGURATION ============
    
    const moods = [
      { 
        label: 'No way', 
        color: '#F76808',
        path: 'M87.2243 26.1185C100.111 -8.70619 149.366 -8.70617 162.252 26.1185L172.374 53.4705C176.425 64.4193 185.057 73.0517 196.006 77.1031L223.358 87.2243C258.183 100.111 258.183 149.366 223.358 162.252L196.006 172.374C185.057 176.425 176.425 185.057 172.374 196.006L162.252 223.358C149.366 258.183 100.111 258.183 87.2243 223.358L77.1031 196.006C73.0517 185.057 64.4193 176.425 53.4705 172.374L26.1185 162.252C-8.70619 149.366 -8.70617 100.111 26.1185 87.2243L53.4705 77.1031C64.4193 73.0517 73.0517 64.4193 77.1031 53.4705L87.2243 26.1185Z',
        // Deep frown
        mouth: 'M100 160 Q125 145 150 160',
        eyeRy: 10,
        eyeOffsetY: 0
      },
      { 
        label: 'Meh', 
        color: '#0091FE',
        path: 'M89.5969 33.3932C101.031 -1.79774 150.817 -1.79773 162.251 33.3932C167.365 49.1311 182.031 59.7864 198.578 59.7864C235.58 59.7864 250.965 107.136 221.03 128.885C207.642 138.611 202.04 155.852 207.154 171.59C218.588 206.781 178.311 236.044 148.375 214.295C134.988 204.568 116.86 204.568 103.473 214.295C73.5375 236.044 33.2599 206.781 44.6941 171.59C49.8077 155.852 44.2059 138.611 30.8184 128.885C0.883203 107.136 16.2679 59.7864 53.2698 59.7864C69.8176 59.7864 84.4834 49.1311 89.5969 33.3932Z',
        // Slight frown
        mouth: 'M100 157 Q125 150 150 157',
        eyeRy: 10,
        eyeOffsetY: 0
      },
      { 
        label: 'OK-ish', 
        color: '#F5D90B',
        path: 'M94.3269 15.5818C102.92 -14.5273 145.59 -14.5273 154.183 15.5818C158.792 31.7331 175.386 41.3134 191.678 37.2295C222.049 29.6165 243.384 66.5701 221.606 89.0661C209.923 101.134 209.923 120.294 221.606 132.362C243.384 154.858 222.049 191.811 191.678 184.198C175.386 180.115 158.792 189.695 154.183 205.846C145.59 235.955 102.92 235.955 94.3269 205.846C89.7176 189.695 73.124 180.115 56.8318 184.198C26.4603 191.811 5.12524 154.858 26.904 132.362C38.5868 120.294 38.5868 101.134 26.904 89.0661C5.12524 66.5701 26.4603 29.6165 56.8318 37.2295C73.124 41.3134 89.7176 31.7331 94.3269 15.5818Z',
        // Neutral straight line
        mouth: 'M100 155 Q125 155 150 155',
        eyeRy: 10,
        eyeOffsetY: 0
      },
      { 
        label: 'Nice', 
        color: '#2CC87C',
        path: 'M99.3494 19.8209C106.028 -6.60698 143.576 -6.60698 150.254 19.8209C154.263 35.6835 171.647 44.0553 186.548 37.2989C211.374 26.0425 234.785 55.3994 218.286 77.098C208.384 90.122 212.677 108.933 227.25 116.371C251.53 128.762 243.174 165.369 215.923 165.999C199.566 166.377 187.536 181.463 190.807 197.494C196.257 224.202 162.427 240.494 144.943 219.58C134.449 207.028 115.154 207.028 104.661 219.58C87.1772 240.494 53.3469 224.202 58.7968 197.494C62.068 181.463 50.0378 166.377 33.681 165.999C6.42968 165.369 -1.92574 128.762 22.3536 116.371C36.9265 108.933 41.22 90.122 31.3173 77.098C14.8188 55.3994 38.2302 26.0425 63.056 37.2989C77.957 44.0553 95.3411 35.6835 99.3494 19.8209Z',
        // Smile
        mouth: 'M100 152 Q125 165 150 152',
        eyeRy: 10,
        eyeOffsetY: 0
      },
      { 
        label: 'Love it', 
        color: '#D6419F',
        path: 'M102.499 17.7043C107.831 -5.90142 141.465 -5.90142 146.797 17.7043C150.253 33.0031 167.809 40.2752 181.071 31.9008C201.533 18.9795 225.316 42.7627 212.395 63.2249C204.021 76.4864 211.293 94.0427 226.592 97.4985C250.197 102.831 250.197 136.465 226.592 141.797C211.293 145.253 204.021 162.809 212.395 176.071C225.316 196.533 201.533 220.316 181.071 207.395C167.809 199.021 150.253 206.293 146.797 221.592C141.465 245.197 107.831 245.197 102.499 221.592C99.0427 206.293 81.4864 199.021 68.2249 207.395C47.7627 220.316 23.9795 196.533 36.9008 176.071C45.2752 162.809 38.0031 145.253 22.7043 141.797C-0.901424 136.465 -0.901424 102.831 22.7043 97.4985C38.0031 94.0427 45.2752 76.4864 36.9008 63.2249C23.9795 42.7627 47.7627 18.9795 68.2249 31.9008C81.4864 40.2752 99.0427 33.0031 102.499 17.7043Z',
        // Big happy smile
        mouth: 'M95 150 Q125 175 155 150',
        eyeRy: 8,
        eyeOffsetY: -2
      }
    ];

    // ============ DOM & STATE ============
    
    const morphPath = document.getElementById('morphPath');
    const mouth = document.getElementById('mouth');
    const leftEye = document.getElementById('leftEye');
    const rightEye = document.getElementById('rightEye');
    const label = document.getElementById('label');
    const glow = document.getElementById('glow');
    const track = document.getElementById('track');
    const thumb = document.getElementById('thumb');
    const progress = document.getElementById('progress');
    const particles = document.getElementById('particles');
    const shape = document.getElementById('shape');

    let currentValue = 0;
    let currentMoodIndex = 0;
    let isDragging = false;
    
    // Pre-sample all paths for fast interpolation
    const NUM_SAMPLES = 120;
    const sampledPaths = moods.map(m => samplePath(m.path, NUM_SAMPLES));

    // ============ HELPERS ============
    
    function interpolateColor(color1, color2, t) {
      const hex2rgb = hex => {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      };
      
      const rgb2hex = ({ r, g, b }) => 
        '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('');
      
      const c1 = hex2rgb(color1);
      const c2 = hex2rgb(color2);
      
      return rgb2hex({
        r: c1.r + (c2.r - c1.r) * t,
        g: c1.g + (c2.g - c1.g) * t,
        b: c1.b + (c2.b - c1.b) * t
      });
    }

    function createParticleBurst(color) {
      const numParticles = 32;
      
      // Star tip angles (approximate positions based on star shapes)
      // More particles cluster around these angles
      const starTips = [
        -Math.PI/2,           // top
        -Math.PI/2 + Math.PI*2/5,
        -Math.PI/2 + Math.PI*4/5,
        -Math.PI/2 + Math.PI*6/5,
        -Math.PI/2 + Math.PI*8/5,
      ];
      
      for (let i = 0; i < numParticles; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.background = color;
        particle.style.left = '50%';
        particle.style.top = '50%';
        
        // Randomize size between 3px and 8px
        const size = 3 + Math.random() * 5;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        
        // Pick a base angle near a star tip, with some randomness
        const tipIndex = Math.floor(Math.random() * starTips.length);
        const baseAngle = starTips[tipIndex];
        const angle = baseAngle + (Math.random() - 0.5) * 0.6; // Â±0.3 radians spread
        
        // Increased distance so particles clear the star shape
        const distance = 120 + Math.random() * 60;
        particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
        particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');
        
        // Stagger delay
        const delay = Math.random() * 150;
        particle.style.animationDelay = delay + 'ms';
        
        particles.appendChild(particle);
        requestAnimationFrame(() => particle.classList.add('burst'));
        setTimeout(() => particle.remove(), 800 + delay);
      }
    }

    // ============ CORE UPDATE ============
    
    function updateVisuals(value, animate = true) {
      const numMoods = moods.length;
      const rawIndex = value * (numMoods - 1);
      const lowerIndex = Math.floor(rawIndex);
      const upperIndex = Math.min(lowerIndex + 1, numMoods - 1);
      const localT = rawIndex - lowerIndex;
      const snappedIndex = Math.round(value * (numMoods - 1));
      
      // Interpolate star shape
      const interpolatedPoints = interpolatePoints(sampledPaths[lowerIndex], sampledPaths[upperIndex], localT);
      morphPath.setAttribute('d', pointsToPath(interpolatedPoints));
      
      // Interpolate mouth shape (simple quadratic curve)
      const mouthPath = interpolateMouth(moods[lowerIndex].mouth, moods[upperIndex].mouth, localT);
      mouth.setAttribute('d', mouthPath);
      
      // Interpolate eye shape
      const eyeRy = moods[lowerIndex].eyeRy + (moods[upperIndex].eyeRy - moods[lowerIndex].eyeRy) * localT;
      const eyeOffsetY = moods[lowerIndex].eyeOffsetY + (moods[upperIndex].eyeOffsetY - moods[lowerIndex].eyeOffsetY) * localT;
      leftEye.setAttribute('ry', eyeRy);
      rightEye.setAttribute('ry', eyeRy);
      leftEye.setAttribute('cy', 115 + eyeOffsetY);
      rightEye.setAttribute('cy', 115 + eyeOffsetY);
      
      // Interpolate color
      const currentColor = interpolateColor(moods[lowerIndex].color, moods[upperIndex].color, localT);
      morphPath.setAttribute('fill', currentColor);
      glow.style.backgroundColor = currentColor;
      progress.style.backgroundColor = currentColor;
      
      // Update thumb
      thumb.style.left = `${value * 100}%`;
      progress.style.width = `${value * 100}%`;
      
      // Update label
      if (snappedIndex !== currentMoodIndex) {
        currentMoodIndex = snappedIndex;
        label.textContent = moods[snappedIndex].label;
        if (animate) {
          label.classList.remove('pop');
          void label.offsetWidth;
          label.classList.add('pop');
        }
      }
      
      currentValue = value;
    }

    function snapToNearest() {
      const snappedIndex = Math.round(currentValue * (moods.length - 1));
      const snappedValue = snappedIndex / (moods.length - 1);
      
      if (Math.abs(snappedValue - currentValue) > 0.01) {
        const startValue = currentValue;
        const startTime = performance.now();
        
        function animate(time) {
          const t = Math.min((time - startTime) / 300, 1);
          const ease = 1 + 2.70158 * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2);
          updateVisuals(startValue + (snappedValue - startValue) * ease, false);
          
          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            updateVisuals(snappedValue, false);
            shape.classList.remove('bounce');
            void shape.offsetWidth;
            shape.classList.add('bounce');
            thumb.classList.remove('snap');
            void thumb.offsetWidth;
            thumb.classList.add('snap');
            createParticleBurst(moods[snappedIndex].color);
          }
        }
        requestAnimationFrame(animate);
      }
    }

    function getValueFromPosition(clientX) {
      const rect = track.getBoundingClientRect();
      return Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    }

    // ============ EVENT LISTENERS ============
    
    thumb.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      thumb.classList.add('dragging');
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) updateVisuals(getValueFromPosition(e.clientX));
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        thumb.classList.remove('dragging');
        snapToNearest();
      }
    });

    thumb.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isDragging = true;
      thumb.classList.add('dragging');
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length) updateVisuals(getValueFromPosition(e.touches[0].clientX));
    }, { passive: true });

    document.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        thumb.classList.remove('dragging');
        snapToNearest();
      }
    });

    track.addEventListener('click', (e) => {
      if (e.target === thumb) return;
      
      const targetIndex = Math.round(getValueFromPosition(e.clientX) * (moods.length - 1));
      const targetValue = targetIndex / (moods.length - 1);
      const startValue = currentValue;
      const startTime = performance.now();
      
      function animate(time) {
        const t = Math.min((time - startTime) / 400, 1);
        const ease = 1 - Math.pow(1 - t, 3);
        updateVisuals(startValue + (targetValue - startValue) * ease, false);
        
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          currentMoodIndex = targetIndex;
          label.textContent = moods[targetIndex].label;
          shape.classList.remove('bounce');
          void shape.offsetWidth;
          shape.classList.add('bounce');
          label.classList.remove('pop');
          void label.offsetWidth;
          label.classList.add('pop');
          createParticleBurst(moods[targetIndex].color);
        }
      }
      requestAnimationFrame(animate);
    });

    document.addEventListener('keydown', (e) => {
      let newIndex = currentMoodIndex;
      
      if (e.key === 'ArrowRight' || e.key === 'ArrowUp') {
        newIndex = Math.min(currentMoodIndex + 1, moods.length - 1);
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
        newIndex = Math.max(currentMoodIndex - 1, 0);
      } else return;
      
      e.preventDefault();
      
      if (newIndex !== currentMoodIndex) {
        const targetValue = newIndex / (moods.length - 1);
        const startValue = currentValue;
        const startTime = performance.now();
        
        function animate(time) {
          const t = Math.min((time - startTime) / 300, 1);
          const ease = 1 - Math.pow(1 - t, 3);
          updateVisuals(startValue + (targetValue - startValue) * ease, true);
          
          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            shape.classList.remove('bounce');
            void shape.offsetWidth;
            shape.classList.add('bounce');
            createParticleBurst(moods[newIndex].color);
          }
        }
        requestAnimationFrame(animate);
      }
    });

    // ============ INIT ============
    
    morphPath.setAttribute('d', moods[0].path);
    updateVisuals(0, false);
  </script>
</body>
</html>
